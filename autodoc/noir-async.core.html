<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>noir-async.core documentation</title></head><body><div id="header"><h1><a href="index.html">Noir-async 1.1.0-beta7 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="noir-async.core.html"><span>noir-async.core</span></a></li><li><a href="noir-async.utils.html"><span>noir-async.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="noir-async.core.html#var-async-push"><span>async-push</span></a></li><li><a href="noir-async.core.html#var-chunked%3F"><span>chunked?</span></a></li><li><a href="noir-async.core.html#var-close-connection"><span>close-connection</span></a></li><li><a href="noir-async.core.html#var-closed%3F"><span>closed?</span></a></li><li><a href="noir-async.core.html#var-defpage-async"><span>defpage-async</span></a></li><li><a href="noir-async.core.html#var-on-close"><span>on-close</span></a></li><li><a href="noir-async.core.html#var-on-receive"><span>on-receive</span></a></li><li><a href="noir-async.core.html#var-one-shot%3F"><span>one-shot?</span></a></li><li><a href="noir-async.core.html#var-readable-channel"><span>readable-channel</span></a></li><li><a href="noir-async.core.html#var-regular%3F"><span>regular?</span></a></li><li><a href="noir-async.core.html#var-request-body-byte-buffer"><span>request-body-byte-buffer</span></a></li><li><a href="noir-async.core.html#var-request-body-str"><span>request-body-str</span></a></li><li><a href="noir-async.core.html#var-websocket%3F"><span>websocket?</span></a></li><li><a href="noir-async.core.html#var-writable-channel"><span>writable-channel</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>noir-async.core documentation</h2><pre class="doc">The main namespace to require when building an app with noir-async.
</pre><div class="public" id="var-async-push"><h3>async-push</h3><div class="usage"><code>(async-push conn data)</code></div><pre class="doc">This should be the only method you need to send data.
All pushes to the client through this are asynchronous.
If it's a websocket this sends a message.
If it's a normal connection, it sends the entire response in one shot and closes the connection.
To start a multi-part connection, send a header with the the option :chunked set to true
  ex: (async-push conn {:chunked true})
If this is a multipart connection (a chunked header has been sent been called earlier) this sends a new body chunk.</pre></div><div class="public" id="var-chunked%3F"><h3>chunked?</h3><div class="usage"><code>(chunked? conn)</code></div><pre class="doc">Is this connection in chunked mode?
</pre></div><div class="public" id="var-close-connection"><h3>close-connection</h3><div class="usage"><code>(close-connection conn)</code></div><pre class="doc">Closes the connection. No more data can be sent / received after this
</pre></div><div class="public" id="var-closed%3F"><h3>closed?</h3><div class="usage"><code>(closed? conn)</code></div><pre class="doc">Returns true if the connection is already closed
</pre></div><div class="public" id="var-defpage-async"><h3>defpage-async</h3><div class="usage"><code>(defpage-async route request-bindings conn-binding &amp; body)</code></div><pre class="doc">Creates an asynchronous noir route. This route can handle both
regular HTTP and Websocket connections. For regular HTTP
responses can be delivered in one shot, or in chunked mode.</pre></div><div class="public" id="var-on-close"><h3>on-close</h3><div class="usage"><code>(on-close {:keys [request-channel response-channel]} handler)</code></div><pre class="doc">Sets a callback to handle a closed connection. Callback takes no arguments.
</pre></div><div class="public" id="var-on-receive"><h3>on-receive</h3><div class="usage"><code>(on-receive {:keys [request-channel]} handler)</code></div><pre class="doc">Sets a callback to handle websocket messages.
Callback takes one argument, a string containing the message.</pre></div><div class="public" id="var-one-shot%3F"><h3>one-shot?</h3><div class="usage"><code>(one-shot? conn)</code></div><pre class="doc">true if the connection is able to send a oneshot response, I.E. not chunked or a websocket.
</pre></div><div class="public" id="var-readable-channel"><h3>readable-channel</h3><div class="usage"><code>(readable-channel {:keys [request-channel]})</code></div><pre class="doc">Returns the connection's readable channel. Useful if you need to directly pipe using lamina.
</pre></div><div class="public" id="var-regular%3F"><h3>regular?</h3><div class="usage"><code>(regular? conn)</code></div><pre class="doc">true if this is a regular HTTP connection, I.E. not a websocket.
</pre></div><div class="public" id="var-request-body-byte-buffer"><h3>request-body-byte-buffer</h3><div class="usage"><code>(request-body-byte-buffer conn)</code></div><pre class="doc">Retrieves the request body as a ByteBuffer
</pre></div><div class="public" id="var-request-body-str"><h3>request-body-str</h3><div class="usage"><code>(request-body-str conn)</code></div><pre class="doc">Retrieves the request body as a string.
</pre></div><div class="public" id="var-websocket%3F"><h3>websocket?</h3><div class="usage"><code>(websocket? conn)</code></div><pre class="doc">True if the connection was is a websocket
</pre></div><div class="public" id="var-writable-channel"><h3>writable-channel</h3><div class="usage"><code>(writable-channel {:keys [request-channel response-channel], :as conn})</code></div><pre class="doc">Returns the connection's writable channel. Useful if you need to directly pipe using lamina.
</pre></div></div></body></html>