{"body":"## Async, Clean, Easy\r\n\r\n[noir](https://github.com/ibdknox/noir) + [aleph](https://github.com/ztellman/aleph) = **noir-async**. A clean library for high-performance async web services in clojure.\r\n\r\n##  Getting Started\r\n\r\n1. Add `[noir-async 1.1.0-beta7]` to your project.clj\r\n1. Use the custom [server.clj](#server-setup)\r\n1. Follow the examples below\r\n1. Read the [full API docs](http://andrewvc.github.com/noir-async/autodoc/) for more examples.\r\n\r\nHere's an example route that responds in one shot:\r\n\r\n```clojure\r\n; Note, same syntax as noir's defpage, but with \"conn\" parameter\r\n(defpage-async \"/route\" [] conn\r\n  (async-push conn {:status 404 :body \"Couldn't find it!\"}))\r\n```\r\n\r\nThis is an example route that handles a websocket:\r\n\r\n```clojure\r\n(defpage-async \"/echo\" [] conn\r\n  (on-receive conn (fn [m] (async-push conn m))))\r\n```\r\n\r\nHere's an example of responding in a chunked fashion:\r\n\r\n```clojure\r\n(defpage-async \"/always-chunky\" [] conn\r\n  ;; Sending the header explicitly indicates a chunked response\r\n  (async-push conn {:status 200 :chunked true})\r\n  (async-push conn \"chunk one\")\r\n  (async-push conn \"chunk two\")\r\n  (close-connection conn))\r\n```\r\n\r\nReading request bodies with aleph can be a little odd, so that interface is sugared:\r\n\r\n```clojure\r\n(defpage-async \"/some-route\" {} conn\r\n  ;; You can also retrieve the body as a ByteBuffer. See full docs for details\r\n  (async-push (str \"Received body:\" (request-body-str conn))))\r\n```\r\n\r\nSince it uses an identical interface for both websockets\r\nand regular HTTP, if you want to handle them differently be\r\nsure to use the websocket? and regular? functions to discern them.\r\n\r\n## Server Setup\r\n\r\nIn your server.clj, you'll want to use aleph as a server explicitly.\r\nBe sure to replace noir-async-chat with the appropriate namespace.\r\n\r\n```clojure\r\n(ns noir-async-chat.server\r\n  (:use aleph.http\r\n        noir.core\r\n        lamina.core)\r\n  (:require\r\n    [noir.server :as nr-server] ))\r\n\r\n(nr-server/load-views \"src/noir_async_chat/views/\")\r\n\r\n(defn -main [& m]\r\n  (let [mode (keyword (or (first m) :dev))\r\n        port (Integer. (get (System/getenv) \"PORT\" \"3000\"))\r\n        noir-handler (nr-server/gen-handler {:mode mode})]\r\n    (start-http-server\r\n      (wrap-ring-handler noir-handler)\r\n      {:port port :websocket true})))\r\n```\r\n\r\n## Full Docs\r\n\r\n[Full API Docs](http://andrewvc.github.com/noir-async/autodoc/) for more examples.\r\n\r\n## Apps Using noir-async\r\n\r\n[engulf](https://github.com/andrewvc/engulf)\r\n[noir-async-chat](https://github.com/andrewvc/noir-async-chat)\r\n\r\n## License\r\n\r\nCopyright (C) 2011 Andrew Cholakian\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"noir-async","google":"UA-17399267-4","tagline":"Seamless, concise, async webservices for clojure."}